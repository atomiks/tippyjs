---
title: Plugins
path: /plugins/
index: 14
---

Plugins add functionality (extra props to use) by hooking into a tippy instance.
By splitting functionality into a plugin, users who don't need the code provided
by the plugin are not burdened with its cost by default.

There are currently 2 plugins exported by the package:

- `followCursor`
- `sticky`

### Usage

Pass the plugin into `tippy.use()`:

```js
import tippy, { followCursor } from 'tippy.js'

tippy.use(followCursor)

// Now you can use the `followCursor` prop
tippy(reference, { followCursor: true })
```

#### Browser

In the browser using the CDN (IIFE version), the `tippy` module gets
automatically configured with all plugins, so you don't need to follow the above
steps. This comes with the downside of extra KBs being downloaded if you don't
need to use the plugins.

It's recommended to use a bundler instead of a CDN to benefit from treeshaking.

### Creating a plugin

A plugin is created by defining an object with the following shape:

```js
const plugin = {
  // Optional (if the plugin provides a prop to use)
  name: 'propName', // e.g. 'followCursor' or 'sticky',
  defaultValue: 'anyValue',

  // Required
  fn(instance) {
    // Internal state
    return {
      // Lifecycle hooks
    }
  },
}
```

The plugin's function `fn` returns an object of
[lifecycle hooks](/lifecycle-hooks).

Here's an example of a plugin that causes a popper to hide if no elements within
it are in focus (for interactivity):

```js
const hideOnPopperBlur = {
  name: 'hideOnPopperBlur',
  defaultValue: true,
  fn() {
    return {
      onCreate(instance) {
        instance.popper.addEventListener('focusout', e => {
          if (
            instance.props.hideOnPopperBlur &&
            !instance.popper.contains(e.relatedTarget)
          ) {
            instance.hide()
          }
        })
      },
    }
  },
}

tippy.use(hideOnPopperBlur)

// Our new prop is enabled by default (defaultValue: true)
tippy(reference)
// Use it as a prop to disable it:
tippy(reference, { hideOnPopperBlur: false })
```

Plugins are invoked per-instance and the plugin function definition takes the
instance as an argument, so you can use private variables to create internal
state in the plugin closure. This is how the `followCursor` plugin works.

### Types

If using TypeScript, you can extend the `Props` interface like so:

```ts
import tippy, { Tippy, Props, followCursor, FollowCursorProps } from 'tippy.js'

tippy.use(followCursor)

type ExtendedProps = Props & FollowCursorProps
const extendedTippy = tippy as Tippy<ExtendedProps>

export default extendedTippy
```
