---
title: Plugins
path: /plugins/
index: 14
---

Plugins add functionality (extra props to use) by hooking into a tippy instance.
By splitting functionality into a plugin, users who don't need the code provided
by the plugin are not burdened with its cost by default.

There are currently 2 plugins exported by the package:

- `followCursor`
- `sticky`

### Usage

Pass the plugin into `tippy.use()`:

```js
import tippy, { followCursor } from 'tippy.js'

tippy.use(followCursor)

// Now you can use the `followCursor` prop
tippy(reference, { followCursor: true })
```

#### Browser

In the browser using the CDN (IIFE version), the `tippy` module gets
automatically configured with all plugins, so you don't need to follow the above
steps. This comes with the downside of extra KBs being downloaded if you don't
need to use the plugins.

It's recommended to use a bundler instead of a CDN to benefit from treeshaking.

### Creating a plugin

A plugin is created by defining a function that returns an object of lifecycle
hooks:

```js
function hideOnPopperBlur() {
  return {
    onCreate(instance) {
      instance.popper.addEventListener('focusout', e => {
        if (
          instance.props.hideOnPopperBlur &&
          !instance.popper.contains(e.relatedTarget)
        ) {
          instance.hide()
        }
      })
    },
  }
}

tippy.use(hideOnPopperBlur)

// Our new prop created by our plugin
tippy(reference, { hideOnPopperBlur: true })
```

Plugins are invoked per-instance and the plugin function definition takes the
instance as an argument, so you can use private variables to create internal
state in the plugin closure. This is how the `followCursor` plugin works.

### Types

If using TypeScript, you can extend the `Props` interface like so:

```ts
import tippy, { Tippy, Props, followCursor, FollowCursorProps } from 'tippy.js'

type ExtendedProps = Props & FollowCursorProps
const extendedTippy = tippy.use(followCursor) as Tippy<ExtendedProps>

export default extendedTippy
```
